<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Fotomultiplicador 2D | QuantumDraft</title>
  <link rel ="stylesheet" href="style.css">
</head>
<body>
  <h1>Fotomultiplicador 2D | QuantumDraft</h1>
  <div class="main-container">
    <div class="controls">
      <button data-tool="pencil" class="tool-btn">Lápiz</button>
      <button data-tool="eraser" class="tool-btn" id="eraser-btn">Borrador</button>
      <button data-tool="rectangle" class="tool-btn">Rectángulo</button>
      <button data-tool="ellipse" class="tool-btn">Elipse</button>
      <button data-tool="polygon" class="tool-btn">Polígono</button>
      <button data-tool="path" class="tool-btn">Path libre</button>

      <div id="shape-params" class="tool-group" style="display:none;">
        <div class="shape-input">
          <label for="shape-width">Ancho:</label>
          <input type="number" id="shape-width" min="1" value="100">
        </div>
        <div class="shape-input">
          <label for="shape-height">Alto:</label>
          <input type="number" id="shape-height" min="1" value="100">
        </div>
      </div>
            
      <label for="color-picker">Color:</label>
      <input type="color" id="color-picker" value="#000000" />
      <label for="size-slider">Tamaño:</label>
      <input type="range" id="size-slider" min="1" max="50" value="5" />
      <button id="clear-btn">Limpiar Canvas</button>
      <input type="text" id="drawing-name" placeholder="Nombre del dibujo" />
      <button id="save-btn">Guardar Dibujo</button>
    </div>
    <div class="canvas-container">
      <canvas id="drawing-canvas"></canvas>
    </div>
  </div>
  <script>
    const canvas = document.getElementById('drawing-canvas');
    const ctx = canvas.getContext('2d');
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let strokeColor = document.getElementById('color-picker').value;
    let lineWidth = document.getElementById('size-slider').value;
    let isErasing = false;
    let compositeMode = 'source-over';
    let currentTool = 'pencil';
    let pathPoints = [];

    function resizeCanvas() {
      const container = canvas.parentElement;
      canvas.width = container.clientWidth;
      canvas.height = container.clientWidth * 0.47;
      ctx.fillStyle = 'rgba(0,0,0,0)';
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    document.getElementById('color-picker').addEventListener('input', e => {
      strokeColor = e.target.value;
    });

    document.getElementById('size-slider').addEventListener('input', e => {
      lineWidth = e.target.value;
    });

    document.getElementById('clear-btn').addEventListener('click', () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    });

    const toolButtons = document.querySelectorAll('.tool-btn');
    toolButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        currentTool = btn.dataset.tool;
        toolButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');

        if (currentTool === 'rectangle' || currentTool === 'ellipse') {
          document.getElementById('shape-params').style.display = 'block';
        } else {
          document.getElementById('shape-params').style.display = 'none';
        }

        if (currentTool === 'eraser') {
          isErasing = true;
          compositeMode = 'destination-out';
        } else {
          isErasing = false;
          compositeMode = 'source-over';
        }
        ctx.globalCompositeOperation = compositeMode;
      });
    });

    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseout', stopDrawing);

    function startDrawing(e) {
      isDrawing = true;
      lastX = e.offsetX;
      lastY = e.offsetY;

      if (currentTool === 'rectangle') {
        const w = parseInt(document.getElementById('shape-width').value);
        const h = parseInt(document.getElementById('shape-height').value);
        ctx.fillStyle = strokeColor;
        ctx.fillRect(lastX, lastY, w, h);
        return;
      }

      if (currentTool === 'ellipse') {
        const w = parseInt(document.getElementById('shape-width').value);
        const h = parseInt(document.getElementById('shape-height').value);
        ctx.beginPath();
        ctx.ellipse(lastX, lastY, w / 2, h / 2, 0, 0, 2 * Math.PI);
        ctx.fillStyle = strokeColor;
        ctx.fill();
        return;
      }

      if (currentTool === 'path') {
        pathPoints = [{ x: lastX, y: lastY }];
      }
    }

    function draw(e) {
      if (!isDrawing) return;

      const x = e.offsetX;
      const y = e.offsetY;

      if (currentTool === 'pencil' || currentTool === 'eraser') {
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(x, y);
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = lineWidth;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.stroke();
        [lastX, lastY] = [x, y];
      }

      if (currentTool === 'path') {
        pathPoints.push({ x, y });
        ctx.beginPath();
        ctx.moveTo(pathPoints[0].x, pathPoints[0].y);
        for (let i = 1; i < pathPoints.length; i++) {
          ctx.lineTo(pathPoints[i].x, pathPoints[i].y);
        }
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = lineWidth;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.fillStyle = strokeColor;
        ctx.fill();
        ctx.stroke();
      }
    }

    function stopDrawing() {
      isDrawing = false;
      if (currentTool === 'path') {
        pathPoints = [];
      }
    }

    let polygonPoints = [];
    canvas.addEventListener('click', e => {
      if (currentTool === 'polygon') {
        const x = e.offsetX;
        const y = e.offsetY;
        polygonPoints.push({ x, y });

        ctx.beginPath();
        ctx.arc(x, y, 3, 0, 2 * Math.PI);
        ctx.fillStyle = 'red';
        ctx.fill();

        if (polygonPoints.length > 2 && confirm('¿Cerrar polígono?')) {
          ctx.beginPath();
          ctx.moveTo(polygonPoints[0].x, polygonPoints[0].y);
          for (let i = 1; i < polygonPoints.length; i++) {
            ctx.lineTo(polygonPoints[i].x, polygonPoints[i].y);
          }
          ctx.closePath();
          ctx.fillStyle = strokeColor;
          ctx.fill();
          polygonPoints = [];
        }
      }
    });

    document.getElementById('save-btn').addEventListener('click', () => {
      const nameInput = document.getElementById('drawing-name').value.trim();
      if (!nameInput) {
        alert("Por favor, introduce un nombre para el dibujo.");
        return;
      }

      const imageData = canvas.toDataURL('image/png');

      fetch('save_canvas.php', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          image: imageData,
          name: nameInput
        })
      })
      .then(res => res.json())
      .then(data => {
        if (data.success) {
          alert(`Dibujo guardado como ${data.filename}`);
        } else {
          alert("Error al guardar: " + data.error);
        }
      })
      .catch(err => {
        alert("Error de conexión: " + err.message);
      });
    });
  </script>


</body>
</html>
